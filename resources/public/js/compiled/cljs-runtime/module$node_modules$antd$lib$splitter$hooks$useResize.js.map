{
"version":3,
"file":"module$node_modules$antd$lib$splitter$hooks$useResize.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/antd/lib/splitter/hooks/useResize.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$antd$lib$splitter$hooks$useResize\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useResize;\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useSizes = require(\"./useSizes\");\n/**\n * Handle user drag resize logic.\n */\nfunction useResize(items, resizableInfos, percentSizes, containerSize, updateSizes) {\n  const limitSizes = items.map(item => [item.min, item.max]);\n  const mergedContainerSize = containerSize || 0;\n  const ptg2px = ptg => ptg * mergedContainerSize;\n  // ======================== Resize ========================\n  function getLimitSize(str, defaultLimit) {\n    if (typeof str === 'string') {\n      return ptg2px((0, _useSizes.getPtg)(str));\n    }\n    return str !== null && str !== void 0 ? str : defaultLimit;\n  }\n  // Real px sizes\n  const [cacheSizes, setCacheSizes] = React.useState([]);\n  const cacheCollapsedSize = React.useRef([]);\n  /**\n   * When start drag, check the direct is `start` or `end`.\n   * This will handle when 2 splitter bar are in the same position.\n   */\n  const [movingIndex, setMovingIndex] = React.useState(null);\n  const getPxSizes = () => percentSizes.map(ptg2px);\n  const onOffsetStart = index => {\n    setCacheSizes(getPxSizes());\n    setMovingIndex({\n      index,\n      confirmed: false\n    });\n  };\n  const onOffsetUpdate = (index, offset) => {\n    var _a;\n    // First time trigger move index update is not sync in the state\n    let confirmedIndex = null;\n    // We need to know what the real index is.\n    if ((!movingIndex || !movingIndex.confirmed) && offset !== 0) {\n      // Search for the real index\n      if (offset > 0) {\n        confirmedIndex = index;\n        setMovingIndex({\n          index,\n          confirmed: true\n        });\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {\n            confirmedIndex = i;\n            setMovingIndex({\n              index: i,\n              confirmed: true\n            });\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index;\n    const numSizes = (0, _toConsumableArray2.default)(cacheSizes);\n    const nextIndex = mergedIndex + 1;\n    // Get boundary\n    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);\n    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);\n    let mergedOffset = offset;\n    // Align with the boundary\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    // Do offset\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    updateSizes(numSizes);\n    return numSizes;\n  };\n  const onOffsetEnd = () => {\n    setMovingIndex(null);\n  };\n  // ======================= Collapse =======================\n  const onCollapse = (index, type) => {\n    const currentSizes = getPxSizes();\n    const currentIndex = type === 'start' ? index : index + 1;\n    const targetIndex = type === 'start' ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      // Collapse directly\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize.current[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);\n      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);\n      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);\n      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);\n      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);\n      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);\n      const halfOffset = (limitEnd - limitStart) / 2;\n      const targetCacheCollapsedSize = cacheCollapsedSize.current[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      const shouldUseCache = targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin;\n      if (shouldUseCache) {\n        currentSizes[targetIndex] = targetCacheCollapsedSize;\n        currentSizes[currentIndex] = currentCacheCollapsedSize;\n      } else {\n        currentSizes[currentIndex] -= halfOffset;\n        currentSizes[targetIndex] += halfOffset;\n      }\n    }\n    updateSizes(currentSizes);\n    return currentSizes;\n  };\n  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index];\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireWildcard","default","_interopRequireDefault","Object","defineProperty","value","useResize","items","resizableInfos","percentSizes","containerSize","updateSizes","getLimitSize","str","defaultLimit","ptg","_useSizes","getPtg","mergedContainerSize","limitSizes","map","item","min","max","ptg2px","cacheSizes","setCacheSizes","React","useState","cacheCollapsedSize","useRef","movingIndex","setMovingIndex","index","onOffsetStart","confirmed","offset","onOffsetUpdate","_a","confirmedIndex","i","resizable","mergedIndex","numSizes","_toConsumableArray2","nextIndex","startMinSize","endMinSize","startMaxSize","endMaxSize","mergedOffset","onOffsetEnd","type","onCollapse","currentSizes","currentIndex","targetIndex","currentSize","targetSize","current","totalSize","currentSizeMin","currentSizeMax","targetSizeMin","targetSizeMax","halfOffset","Math","limitEnd","limitStart","targetCacheCollapsedSize","currentCacheCollapsedSize"]
}
