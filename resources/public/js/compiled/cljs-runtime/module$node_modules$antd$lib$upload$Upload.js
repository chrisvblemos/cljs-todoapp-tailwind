shadow$provide.module$node_modules$antd$lib$upload$Upload=function(global,require,module,exports){"use client";global=require("module$node_modules$$babel$runtime$helpers$interopRequireWildcard").default;module=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;Object.defineProperty(exports,"__esModule",{value:!0});exports.default=exports.LIST_IGNORE=void 0;var _toConsumableArray2=module(require("module$node_modules$$babel$runtime$helpers$toConsumableArray")),React=
global(require("module$node_modules$react$index")),_reactDom=require("module$node_modules$react_dom$index"),_classnames=module(require("module$node_modules$classnames$index")),_rcUpload=module(require("module$node_modules$rc_upload$lib$index")),_useMergedState=module(require("module$node_modules$rc_util$lib$hooks$useMergedState")),_warning=require("module$node_modules$antd$lib$_util$warning"),_configProvider=require("module$node_modules$antd$lib$config_provider$index"),_DisabledContext=module(require("module$node_modules$antd$lib$config_provider$DisabledContext")),
_locale=require("module$node_modules$antd$lib$locale$index"),_en_US=module(require("module$node_modules$antd$lib$locale$en_US")),_style=module(require("module$node_modules$antd$lib$upload$style$index")),_UploadList=module(require("module$node_modules$antd$lib$upload$UploadList$index")),_utils=require("module$node_modules$antd$lib$upload$utils"),__awaiter=function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value)})}return new (P||
(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};const LIST_IGNORE=exports.LIST_IGNORE=`__LIST_IGNORE_${Date.now()}__`;require=React.forwardRef((props,ref)=>{const {fileList,defaultFileList,
onRemove,showUploadList=!0,listType="text",onPreview,onDownload,onChange,onDrop,previewFile,disabled:customDisabled,locale:propLocale,iconRender,isImageUrl,progress,prefixCls:customizePrefixCls,className,type="select",children,style,itemRender,maxCount,data={},multiple=!1,hasControlInside=!0,action="",accept="",supportServerRender=!0,rootClassName}=props;var disabled=React.useContext(_DisabledContext.default);const mergedDisabled=null!==customDisabled&&void 0!==customDisabled?customDisabled:disabled,
[mergedFileList,setMergedFileList]=(0,_useMergedState.default)(defaultFileList||[],{value:fileList,postState:list=>null!==list&&void 0!==list?list:[]}),[dragState,setDragState]=React.useState("drop"),upload=React.useRef(null),wrapRef=React.useRef(null);disabled=(0,_warning.devUseWarning)("Upload");disabled("fileList"in props||!("value"in props),"usage","`value` is not a valid prop, do you mean `fileList`?");disabled.deprecated(!("transformFile"in props),"transformFile","beforeUpload");React.useMemo(()=>
{const timestamp=Date.now();(fileList||[]).forEach((file,index)=>{file.uid||Object.isFrozen(file)||(file.uid=`__AUTO__${timestamp}_${index}__`)})},[fileList]);const onInternalChange=(file,changedFileList,event)=>{let cloneList=(0,_toConsumableArray2.default)(changedFileList);changedFileList=!1;1===maxCount?cloneList=cloneList.slice(-1):maxCount&&(changedFileList=cloneList.length>maxCount,cloneList=cloneList.slice(0,maxCount));(0,_reactDom.flushSync)(()=>{setMergedFileList(cloneList)});const changeInfo=
{file,fileList:cloneList};event&&(changeInfo.event=event);changedFileList&&"removed"!==file.status&&!cloneList.some(f=>f.uid===file.uid)||(0,_reactDom.flushSync)(()=>{null===onChange||void 0===onChange?void 0:onChange(changeInfo)})},onBatchStart=batchFileInfoList=>{const filteredFileInfoList=batchFileInfoList.filter(info=>!info.file[LIST_IGNORE]);if(filteredFileInfoList.length){batchFileInfoList=filteredFileInfoList.map(info=>(0,_utils.file2Obj)(info.file));var newFileList=(0,_toConsumableArray2.default)(mergedFileList);
batchFileInfoList.forEach(fileObj=>{newFileList=(0,_utils.updateFileList)(fileObj,newFileList)});batchFileInfoList.forEach((fileObj,index)=>{let triggerFileObj=fileObj;if(filteredFileInfoList[index].parsedFile)fileObj.status="uploading";else{({originFileObj:index}=fileObj);let clone;try{clone=new File([index],index.name,{type:index.type})}catch(_a){clone=new Blob([index],{type:index.type}),clone.name=index.name,clone.lastModifiedDate=new Date,clone.lastModified=(new Date).getTime()}clone.uid=fileObj.uid;
triggerFileObj=clone}onInternalChange(triggerFileObj,newFileList)})}},onSuccess=(response,file,xhr)=>{try{"string"===typeof response&&(response=JSON.parse(response))}catch(_a){}(0,_utils.getFileItem)(file,mergedFileList)&&(file=(0,_utils.file2Obj)(file),file.status="done",file.percent=100,file.response=response,file.xhr=xhr,response=(0,_utils.updateFileList)(file,mergedFileList),onInternalChange(file,response))},onProgress=(e,file)=>{if((0,_utils.getFileItem)(file,mergedFileList)){file=(0,_utils.file2Obj)(file);
file.status="uploading";file.percent=e.percent;var nextFileList=(0,_utils.updateFileList)(file,mergedFileList);onInternalChange(file,nextFileList,e)}},onError=(error,response,file)=>{(0,_utils.getFileItem)(file,mergedFileList)&&(file=(0,_utils.file2Obj)(file),file.error=error,file.response=response,file.status="error",error=(0,_utils.updateFileList)(file,mergedFileList),onInternalChange(file,error))},handleRemove=file=>{let currentFile;Promise.resolve("function"===typeof onRemove?onRemove(file):onRemove).then(ret=>
{var _a;!1!==ret&&(ret=(0,_utils.removeFileItem)(file,mergedFileList))&&(currentFile=Object.assign(Object.assign({},file),{status:"removed"}),null===mergedFileList||void 0===mergedFileList?void 0:mergedFileList.forEach(item=>{const matchKey=void 0!==currentFile.uid?"uid":"name";item[matchKey]!==currentFile[matchKey]||Object.isFrozen(item)||(item.status="removed")}),null===(_a=upload.current)||void 0===_a?void 0:_a.abort(currentFile),onInternalChange(currentFile,ret))})};disabled=e=>{setDragState(e.type);
"drop"===e.type&&(null===onDrop||void 0===onDrop?void 0:onDrop(e))};React.useImperativeHandle(ref,()=>({onBatchStart,onSuccess,onProgress,onError,fileList:mergedFileList,upload:upload.current,nativeElement:wrapRef.current}));const {getPrefixCls,direction,upload:ctxUpload}=React.useContext(_configProvider.ConfigContext),prefixCls=getPrefixCls("upload",customizePrefixCls),rcUploadProps=Object.assign(Object.assign({onBatchStart,onError,onProgress,onSuccess},props),{data,multiple,action,accept,supportServerRender,
prefixCls,disabled:mergedDisabled,beforeUpload:(file,fileListArgs)=>__awaiter(void 0,void 0,void 0,function*(){const {beforeUpload,transformFile}=props;let parsedFile=file;if(beforeUpload){const result=yield beforeUpload(file,fileListArgs);if(!1===result)return!1;delete file[LIST_IGNORE];if(result===LIST_IGNORE)return Object.defineProperty(file,LIST_IGNORE,{value:!0,configurable:!0}),!1;"object"===typeof result&&result&&(parsedFile=result)}transformFile&&(parsedFile=yield transformFile(parsedFile));
return parsedFile}),onChange:void 0,hasControlInside});delete rcUploadProps.className;delete rcUploadProps.style;children&&!mergedDisabled||delete rcUploadProps.id;var wrapperCls=`${prefixCls}-wrapper`;const [wrapCSSVar,hashId,cssVarCls]=(0,_style.default)(prefixCls,wrapperCls),[contextLocale]=(0,_locale.useLocale)("Upload",_en_US.default.Upload),{showRemoveIcon,showPreviewIcon,showDownloadIcon,removeIcon,previewIcon,downloadIcon,extra}="boolean"===typeof showUploadList?{}:showUploadList,realShowRemoveIcon=
"undefined"===typeof showRemoveIcon?!mergedDisabled:showRemoveIcon;ref=(button,buttonVisible)=>showUploadList?React.createElement(_UploadList.default,{prefixCls,listType,items:mergedFileList,previewFile,onPreview,onDownload,onRemove:handleRemove,showRemoveIcon:realShowRemoveIcon,showPreviewIcon,showDownloadIcon,removeIcon,previewIcon,downloadIcon,iconRender,extra,locale:Object.assign(Object.assign({},contextLocale),propLocale),isImageUrl,progress,appendAction:button,appendActionVisible:buttonVisible,
itemRender,disabled:mergedDisabled}):button;wrapperCls=(0,_classnames.default)(wrapperCls,className,rootClassName,hashId,cssVarCls,null===ctxUpload||void 0===ctxUpload?void 0:ctxUpload.className,{[`${prefixCls}-rtl`]:"rtl"===direction,[`${prefixCls}-picture-card-wrapper`]:"picture-card"===listType,[`${prefixCls}-picture-circle-wrapper`]:"picture-circle"===listType});const mergedStyle=Object.assign(Object.assign({},null===ctxUpload||void 0===ctxUpload?void 0:ctxUpload.style),style);if("drag"===type){const dragCls=
(0,_classnames.default)(hashId,prefixCls,`${prefixCls}-drag`,{[`${prefixCls}-drag-uploading`]:mergedFileList.some(file=>"uploading"===file.status),[`${prefixCls}-drag-hover`]:"dragover"===dragState,[`${prefixCls}-disabled`]:mergedDisabled,[`${prefixCls}-rtl`]:"rtl"===direction});return wrapCSSVar(React.createElement("span",{className:wrapperCls,ref:wrapRef},React.createElement("div",{className:dragCls,style:mergedStyle,onDrop:disabled,onDragOver:disabled,onDragLeave:disabled},React.createElement(_rcUpload.default,
Object.assign({},rcUploadProps,{ref:upload,className:`${prefixCls}-btn`}),React.createElement("div",{className:`${prefixCls}-drag-container`},children))),ref()))}disabled=(0,_classnames.default)(prefixCls,`${prefixCls}-select`,{[`${prefixCls}-disabled`]:mergedDisabled,[`${prefixCls}-hidden`]:!children});disabled=React.createElement("div",{className:disabled},React.createElement(_rcUpload.default,Object.assign({},rcUploadProps,{ref:upload})));return"picture-card"===listType||"picture-circle"===listType?
wrapCSSVar(React.createElement("span",{className:wrapperCls,ref:wrapRef},ref(disabled,!!children))):wrapCSSVar(React.createElement("span",{className:wrapperCls,ref:wrapRef},disabled,ref()))});require.displayName="Upload";exports.default=require}
//# sourceMappingURL=module$node_modules$antd$lib$upload$Upload.js.map
