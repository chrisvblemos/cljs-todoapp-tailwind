{"version":3,"sources":["front/utils.cljs"],"mappings":";AAGA;;;;oCAAA,pCAAMA,gFAGHC;AAHH,AAIE,IAAMC,OAAK,AAACC;AAAZ,AACE,oBAAI,qDAAA,rDAACC,+CAAOH,yFAAOC;AACjB,QAACF,kEAAAA,yEAAAA,TAAsBC,qDAAAA;;AACvBC;;;AAEN,2BAAA,3BAAMG,8DACHC;AADH,AAEE,YAAAC,KAAUD;;AAEZ,2BAAA,3BAAME,8DACHC,KAAKC;AADR,AAEE,IAAMC,cAAY,wCAAA,IAAA,IAAA,IAAA,pDAAW,AAACN,yBAAUI;IAClCG,oBAAkB,8CAAA,IAAA,IAAA,IAAA,1DAAW,AAACP,yBAAUK;AAD9C,AAEE,qGAAA,yBAAA,9HAACG,kHAAiBF,qBAAqBC;;AACvC,GACE,CAAGD,cAAYC;AADjB;;AAAA,GAEE,AAACE,6CAAEH,YAAYC;AAFjB;;AAAA,GAGE,CAAGD,cAAYC;AAHjB;;AAAA;;;;;AAKJ,8BAAA,sCAAAG,pEAAMI,6EACyBG;AAD/B,AAAA,IAAAN,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;eAAA,AAAAE,4CAAAF,eAAA,tEACWI;qBADX,AAAAF,4CAAAF,eAAA,5EACoBK;AADpB,AAEE,IAAME,gBAAc,AAACf,yBAAaY,SAASE;AAA3C,AACE,oBAAID;AAAJ;;AAEE,IAAAG,WAAMD;IAANC,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;;AAAA,MAAA,KAAAE,MAAA,CAAA,mEAAAF","names":["front.utils/safe-random-task-uuid","tasks","uuid","cljs.core/random-uuid","cljs.core.get_in","front.utils/str->date","date-str","js/Date","front.utils/compare-date","date","other-date","parsed-date","parsed-other-date","cljs.core.prn","cljs.core._EQ_","p__20663","map__20664","cljs.core/--destructure-map","cljs.core.get","front.utils/get-task-status","deadline","is-done?","date-today","time-relative","G__20665","cljs.core/Keyword","js/Error"],"sourcesContent":["(ns front.utils\n  (:require [clojure.string]))\n\n(defn safe-random-task-uuid\n  \"Generates a random task UUID\n  without duplicates.\"\n  [tasks]\n  (let [uuid (random-uuid)]\n    (if (get-in tasks [uuid])\n      (safe-random-task-uuid tasks)\n      uuid)))\n\n(defn str->date\n  [date-str]\n  (js/Date. date-str))\n\n(defn compare-date\n  [date other-date]\n  (let [parsed-date (.setHours (str->date date) 0 0 0 0)\n        parsed-other-date (.setHours (str->date other-date) 0 0 0 0)]\n    (prn \"comparing \" parsed-date \" with \" parsed-other-date)\n    (cond\n      (< parsed-date parsed-other-date) :past\n      (= parsed-date parsed-other-date) :today\n      (> parsed-date parsed-other-date) :future)))\n\n(defn get-task-status\n  [{:keys [deadline is-done?]} date-today]\n  (let [time-relative (compare-date deadline date-today)]\n    (if is-done?\n      :done\n      (case time-relative\n        :past :late\n        :today :today\n        :future :pending))))\n\n"]}