{
"version":3,
"file":"module$node_modules$antd$lib$transfer$hooks$useData.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,mDAAA,CAAwE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG5GC,MAAAA,CAA0BH,OAAA,CAAQ,mEAAR,CAAyDI,CAAAA,OACvFC,OAAOC,CAAAA,cAAP,CAAsBJ,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CK,MAAO,CAAA,CADoC,CAA7C,CAGAL,QAAQE,CAAAA,OAAR,CAAkB,IAAK,EACvB,KAAII,MAAQL,MAAA,CAAwBH,OAAA,CAAQ,iCAAR,CAAxB,CAAZ,CACIS,WAAaT,OAAA,CAAQ,8CAAR,CA2BFE,QAAQE,CAAAA,OAAR,CA1BC,CAACM,UAAD,CAAaC,MAAb,CAAqBC,UAArB,CAAAC,EAAoC,CAClD,MAAMC,iBAAmBN,KAAMO,CAAAA,OAAN,CAAc,EAAA,EAAyBC,CAAlBN,UAAkBM;AAAJ,EAAIA,EAAAA,GAAnB,CAAuBC,MAAA,EAC9DN,MAAJ,CACSN,MAAOa,CAAAA,MAAP,CAAcb,MAAOa,CAAAA,MAAP,CAAc,EAAd,CAAkBD,MAAlB,CAAd,CAAyC,CAC9CE,IAAKR,MAAA,CAAOM,MAAP,CADyC,CAAzC,CADT,CAKOA,MANoC,CAApB,CAOrB,CAACP,UAAD,CAAaC,MAAb,CAPqB,CAAzB,CAQM,CAACS,cAAD,CAAiBC,eAAjB,CAAA,CAAoCb,KAAMO,CAAAA,OAAN,CAAc,EAAA,EAAM,CAC5D,MAAMO,SAAW,EAAjB,CACMC,UAAgBC,KAAJ,CAA6BC,CAAlBb,UAAkBa,EAAJ,EAAIA,EAAAA,MAA7B,CADlB,CAEMC,cAAgB,GAAIjB,UAAWkB,CAAAA,YAAf,EAA6Bf,UAA7B,EAA2C,EAA3C,CACtBE,iBAAiBc,CAAAA,OAAjB,CAAyBX,MAAA,EAAU,CAG7BS,aAAcG,CAAAA,GAAd,CAAkBZ,MAAOE,CAAAA,GAAzB,CAAJ,CACEI,SAAA,CAAUG,aAAcI,CAAAA,GAAd,CAAkBb,MAAOE,CAAAA,GAAzB,CAAV,CADF,CAC6CF,MAD7C,CAGEK,QAASS,CAAAA,IAAT,CAAcd,MAAd,CAN+B,CAAnC,CASA,OAAO,CAACK,QAAD,CAAWC,SAAX,CAbqD,CAApB,CAcvC,CAACT,gBAAD,CAAmBF,UAAnB,CAA+BD,MAA/B,CAduC,CAe1C,OAAO,CAACG,gBAAD;AAAmBM,cAAnB,CAAmCC,eAAnC,CAxB2C,CAV4D;",
"sources":["node_modules/antd/lib/transfer/hooks/useData.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$antd$lib$transfer$hooks$useData\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _transKeys = require(\"../../_util/transKeys\");\nconst useData = (dataSource, rowKey, targetKeys) => {\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      return Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    const leftData = [];\n    const rightData = new Array((targetKeys || []).length);\n    const targetKeysMap = (0, _transKeys.groupKeysMap)(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        rightData[targetKeysMap.get(record.key)] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys, rowKey]);\n  return [mergedDataSource, leftDataSource, rightDataSource];\n};\nvar _default = exports.default = useData;\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireWildcard","default","Object","defineProperty","value","React","_transKeys","dataSource","rowKey","targetKeys","useData","mergedDataSource","useMemo","map","record","assign","key","leftDataSource","rightDataSource","leftData","rightData","Array","length","targetKeysMap","groupKeysMap","forEach","has","get","push"]
}
