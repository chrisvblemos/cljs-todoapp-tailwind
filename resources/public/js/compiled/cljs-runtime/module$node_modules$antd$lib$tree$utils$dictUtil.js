shadow$provide.module$node_modules$antd$lib$tree$utils$dictUtil=function(global,require,module,exports){function traverseNodesKey(treeData,callback,fieldNames){const {key:fieldKey,children:fieldChildren}=fieldNames;treeData.forEach(function(dataNode){const children=dataNode[fieldChildren];!1!==callback(dataNode[fieldKey],dataNode)&&traverseNodesKey(children||[],callback,fieldNames)})}global=require("module$node_modules$$babel$runtime$helpers$interopRequireDefault").default;Object.defineProperty(exports,
"__esModule",{value:!0});exports.calcRangeKeys=function(_ref){let {treeData,expandedKeys,startKey,endKey,fieldNames}=_ref;const keys=[];let record=0;if(startKey&&startKey===endKey)return[startKey];if(!startKey||!endKey)return[];traverseNodesKey(treeData,key=>{if(2===record)return!1;if(key===startKey||key===endKey)if(keys.push(key),0===record)record=1;else{if(1===record)return record=2,!1}else 1===record&&keys.push(key);return expandedKeys.includes(key)},(0,_treeUtil.fillFieldNames)(fieldNames));return keys};
exports.convertDirectoryKeysToNodes=function(treeData,keys,fieldNames){const restKeys=(0,_toConsumableArray2.default)(keys),nodes=[];traverseNodesKey(treeData,(key,node)=>{key=restKeys.indexOf(key);-1!==key&&(nodes.push(node),restKeys.splice(key,1));return!!restKeys.length},(0,_treeUtil.fillFieldNames)(fieldNames));return nodes};var _toConsumableArray2=global(require("module$node_modules$$babel$runtime$helpers$toConsumableArray")),_treeUtil=require("module$node_modules$rc_tree$lib$utils$treeUtil")}
//# sourceMappingURL=module$node_modules$antd$lib$tree$utils$dictUtil.js.map
