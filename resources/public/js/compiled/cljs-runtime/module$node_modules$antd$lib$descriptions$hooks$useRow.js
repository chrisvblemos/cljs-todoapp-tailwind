shadow$provide.module$node_modules$antd$lib$descriptions$hooks$useRow=function(global,require,module,exports){function getCalcRows(rowItems,mergedColumn){let rows=[],tmpRow=[],exceed=!1,count=0;rowItems.filter(n=>n).forEach(rowItem=>{var {filled}=rowItem,e=["filled"],t={},p;for(p in rowItem)Object.prototype.hasOwnProperty.call(rowItem,p)&&0>e.indexOf(p)&&(t[p]=rowItem[p]);if(null!=rowItem&&"function"===typeof Object.getOwnPropertySymbols){var i=0;for(p=Object.getOwnPropertySymbols(rowItem);i<p.length;i++)0>
e.indexOf(p[i])&&Object.prototype.propertyIsEnumerable.call(rowItem,p[i])&&(t[p[i]]=rowItem[p[i]])}filled?(tmpRow.push(t),rows.push(tmpRow),tmpRow=[],count=0):(filled=mergedColumn-count,count+=rowItem.span||1,count>=mergedColumn?(count>mergedColumn?(exceed=!0,tmpRow.push(Object.assign(Object.assign({},t),{span:filled}))):tmpRow.push(t),rows.push(tmpRow),tmpRow=[],count=0):tmpRow.push(t))});0<tmpRow.length&&rows.push(tmpRow);rows=rows.map(rows=>{const count=rows.reduce((acc,item)=>acc+(item.span||
1),0);if(count<mergedColumn){const last=rows[rows.length-1];last.span=mergedColumn-(count-(last.span||1))}return rows});return[rows,exceed]}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _react=require("module$node_modules$react$index"),_warning=require("module$node_modules$antd$lib$_util$warning");exports.default=(mergedColumn,items)=>{const [rows,exceed]=(0,_react.useMemo)(()=>getCalcRows(items,mergedColumn),[items,mergedColumn]);(0,_warning.devUseWarning)("Descriptions")(!exceed,
"usage","Sum of column `span` in a line not match `column` of Descriptions.");return rows}}
//# sourceMappingURL=module$node_modules$antd$lib$descriptions$hooks$useRow.js.map
