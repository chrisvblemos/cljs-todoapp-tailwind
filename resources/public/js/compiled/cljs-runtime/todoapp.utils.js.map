{"version":3,"sources":["todoapp/utils.cljs"],"mappings":";AAGA;;;;sCAAA,tCAAMA,oFAGHC;AAHH,AAIE,IAAMC,OAAK,AAACC;AAAZ,AACE,oBAAI,qDAAA,rDAACC,+CAAOH,yFAAOC;AACjB,QAACF,oEAAAA,2EAAAA,TAAsBC,uDAAAA;;AACvBC;;;AAEN,6BAAA,7BAAMG,kEACHC;AADH,AAEE,YAAAC,KAAUD;;AAEZ,6BAAA,7BAAME,kEACHC,KAAKC;AADR,AAEE,IAAMC,cAAY,0CAAA,IAAA,IAAA,IAAA,tDAAW,AAACN,2BAAUI;IAClCG,oBAAkB,gDAAA,IAAA,IAAA,IAAA,5DAAW,AAACP,2BAAUK;AAD9C,AAEE,qGAAA,yBAAA,9HAACG,kHAAiBF,qBAAqBC;;AACvC,GACE,CAAGD,cAAYC;AADjB;;AAAA,GAEE,AAACE,6CAAEH,YAAYC;AAFjB;;AAAA,GAGE,CAAGD,cAAYC;AAHjB;;AAAA;;;;;AAKJ,gCAAA,wCAAAG,xEAAMI,iFACyBG;AAD/B,AAAA,IAAAN,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;eAAA,AAAAE,4CAAAF,eAAA,tEACWI;qBADX,AAAAF,4CAAAF,eAAA,5EACoBK;AADpB,AAEE,IAAME,gBAAc,AAACf,2BAAaY,SAASE;AAA3C,AACE,oBAAID;AAAJ;;AAEE,IAAAG,WAAMD;IAANC,eAAA,EAAA,CAAAA,oBAAAC,oBAAA,AAAAD,aAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;KAAA;AAAA;;;KAAA;AAAA;;;;AAAA,MAAA,KAAAE,MAAA,CAAA,mEAAAF","names":["todoapp.utils/safe-random-task-uuid","tasks","uuid","cljs.core/random-uuid","cljs.core.get_in","todoapp.utils/str->date","date-str","js/Date","todoapp.utils/compare-date","date","other-date","parsed-date","parsed-other-date","cljs.core.prn","cljs.core._EQ_","p__11982","map__11995","cljs.core/--destructure-map","cljs.core.get","todoapp.utils/get-task-status","deadline","is-done?","date-today","time-relative","G__12022","cljs.core/Keyword","js/Error"],"sourcesContent":["(ns todoapp.utils\n  (:require [clojure.string]))\n\n(defn safe-random-task-uuid\n  \"Generates a random task UUID\n  without duplicates.\"\n  [tasks]\n  (let [uuid (random-uuid)]\n    (if (get-in tasks [uuid])\n      (safe-random-task-uuid tasks)\n      uuid)))\n\n(defn str->date\n  [date-str]\n  (js/Date. date-str))\n\n(defn compare-date\n  [date other-date]\n  (let [parsed-date (.setHours (str->date date) 0 0 0 0)\n        parsed-other-date (.setHours (str->date other-date) 0 0 0 0)]\n    (prn \"comparing \" parsed-date \" with \" parsed-other-date)\n    (cond\n      (< parsed-date parsed-other-date) :past\n      (= parsed-date parsed-other-date) :today\n      (> parsed-date parsed-other-date) :future)))\n\n(defn get-task-status\n  [{:keys [deadline is-done?]} date-today]\n  (let [time-relative (compare-date deadline date-today)]\n    (if is-done?\n      :done\n      (case time-relative\n        :past :late\n        :today :today\n        :future :pending))))\n\n"]}